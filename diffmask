#!/usr/bin/python
#	vim:fileencoding=utf-8
# Create merged 'package.mask' file and maintain 'package.unmask' using it
# (C) 2010 Michał Górny, distributed under the terms of 3-clause BSD license

MY_PN='diffmask'
MY_PV='0.3.2'

import codecs, optparse, os, os.path, sys, tempfile
import portage

from portage.dep import Atom, match_from_list
from portage.exception import InvalidAtom

def toString(obj):
	if hasattr(obj, 'toString'):
		return obj.toString()
	else:
		return obj

class DiffmaskList(list):
	""" A list class extended with a simple toString() method. """
	def toString(self):
		return ''.join([toString(x) for x in self])

	def find(self, key):
		for e in self:
			if e == key:
				return e
		else:
			return None

class MaskFile(DiffmaskList):
	class MaskRepo(DiffmaskList):
		class MaskBlock(DiffmaskList):
			""" A single block of package.mask file. Basically a list of
				atoms, keeping the comments as well. """

			class MaskAtom:
				def __init__(self, s):
					# XXX: Read and pass the EAPI
					try:
						self.atom = Atom(s, allow_wildcard = True)
					except InvalidAtom:
						self.atom = s
					else:
						if self.atom != s:
							raise AssertionError('Atom(%s) stringifies to %s' \
									% (s.rstrip(), self.atom.rstrip()))

				def toString(self):
					return self.atom

				def __contains__(self, cpv):
					if not isinstance(self.atom, Atom):
						return False
					else:
						return match_from_list(self.atom, [cpv])

			def __eq__(self, other):
				return (self.comment == other.comment and DiffmaskList.__eq__(self, other))

			def __contains__(self, cpv):
				if isinstance(cpv, self.MaskAtom):
					return DiffmaskList.__contains__(self, cpv)

				for atom in self:
					if cpv in atom:
						return True
				return False

			def toString(self):
				l = [DiffmaskList.toString(self)]
				return ''.join(self.before + self.comment + l + self.after)

			def append(self, data):
				if not isinstance(data, self.MaskAtom):
					data = self.MaskAtom(data)
				DiffmaskList.append(self, data)

			def __init__(self, data):
				DiffmaskList.__init__(self)
				self.before = []
				self.comment = []
				self.after = []

				for l in data:
					if not self:
						if not self.comment and not l.strip():
							self.before.append(l)
						elif l.startswith('#') or not l.strip():
							self.comment.append(l)
						else:
							self.append(l)
					elif l.startswith('#') or not l.strip():
						self.after.append(l)
					else:
						self.append(l)

		def append(self, data):
			if not isinstance(data, self.MaskBlock):
				data = self.MaskBlock(data)
			DiffmaskList.append(self, data)

		def extend(self, l):
			for x in l:
				self.append(x)

		def toString(self):
			out = []
			if self.name:
				out.append('\n## *%s*\n\n' % self.name)
			out.extend([x.toString() for x in self])
			return ''.join(out)

		def __init__(self, name):
			DiffmaskList.__init__(self)
			self.name = name

	def __getitem__(self, name):
		if isinstance(name, int):
			return DiffmaskList.__getitem__(self, name)
		else:
			for r in self:
				if r.name == name:
					return r
			raise KeyError('No such repo')

	def __init__(self, data):
		repo = self.MaskRepo(None)
		DiffmaskList.__init__(self, [repo])
		buf = []
		pbuf = None
		tmprepo = []
		tmprepos = [(None, tmprepo)]
		gotatoms = False

		for l in data:
			if l.startswith('#'):
				newrepo = (l.startswith('## *') and l.endswith('*\n')) # repo name
				newmask = ('<' in l and '>' in l) # a mask header

				if gotatoms or newrepo:
					tmprepo.append(buf)
					pbuf = buf
					buf = []
					gotatoms = False
				if newrepo:
					tmprepo = []
					tmprepos.append((l[4:-2], tmprepo))
					continue
				elif not gotatoms and newmask and pbuf is not None:
					pbuf.extend(buf)
					pbuf = None
					buf = []
			elif ''.join(l).strip():
				gotatoms = True
			buf.append(l)

		if ''.join(buf).strip():
			tmprepo.append(buf)

		for reponame, entries in tmprepos:
			repo = self.MaskRepo(reponame)
			repo.extend(entries)
			self.append(repo)

		# cleanup leading/trailing whitespace (one belonging to repo header)
		for r in self:
			try:
				if r[0].before[0] == '\n':
					del r[0].before[0]
			except IndexError:
				pass
			try:
				if r[-1].after[-1] == '\n':
					del r[-1].after[-1]
			except IndexError:
				pass

class UnmaskFile(MaskFile):
	def __init__(self, path):
		if os.path.exists(path):
			data = codecs.open(path, 'r', 'utf8').readlines()
		else:
			data = []
		MaskFile.__init__(self, data)
		self.path = path

	def write(self, path = None):
		if path is None:
			path = self.path

		c = self.toString()

		try:
			origf = codecs.open(path, 'r', 'utf8')
		except (OSError, IOError):
			pass
		else:
			if origf.read().strip() == c.strip():
				origf.close()
				print('The unmask file is up-to-date.')
				return path
			else:
				origf.close()

		newfn = portage.util.new_protect_filename(path)
		# Always try hard to get a diff.
		if newfn == path:
			open(newfn, 'w').close()
			newfn = portage.util.new_protect_filename(path)
		newf = codecs.open(newfn, 'w', 'utf8')
		newf.write(c)

		print('New package.unmask saved as %s.\nPlease run dispatch-conf or etc-update to merge it.' % newfn)
		return newfn

class UnmaskFileClean(UnmaskFile):
	class UnmaskRepoClean(MaskFile.MaskRepo):
		def __init__(self, maskr, unmaskr, noner):
			""" Try to match blocks in unmaskr (unmask entries associated with repo)
				and noner (unassociated unmask entries) to those in maskr (mask entries
				associated with repo). Create blocklist containing matched entries. """
			MaskFile.MaskRepo.__init__(self, maskr.name)
			tblocks = []

			for b in unmaskr + noner:
				# first try to get exact match
				cb = maskr.find(b)
				if cb is not None:
					tblocks.append(cb)
				else:
					# then try partial matches
					# (both comment & atoms as they might come
					# from a set of different masks)
					for cb in maskr:
						if cb.comment == b.comment:
							tblocks.append(cb)
							continue
						for a in b:
							if a in cb:
								tblocks.append(cb)
								break

			# sort & uniq, now we have to get exact matches
			for cb in maskr:
				if cb in tblocks:
					self.append(cb)
					tblocks.remove(cb)
			if tblocks:
				raise AssertionError('At least a single match failed in the sorting loop')

	def __init__(self, mask, unmask):
		""" Update and cleanup 'unmask' file to match 'mask' file. """
		DiffmaskList.__init__(self)
		self.path = unmask.path

		# find the repo containing unmatched entries
		# (in fact it should be always the first one but better safe than sorry)
		try:
			nonerepo = unmask[None]
		except KeyError:
			nonerepo = []

		for mr in mask:
			if mr.name is not None:
				try:
					r = unmask[mr.name]
				except KeyError: # repo only in mask file
					r = []

				outr = self.UnmaskRepoClean(mr, r, nonerepo)
				if outr:
					self.append(outr)

		# repos which are only in unmask file are dropped implicitly

class MaskMerge(DiffmaskList):
	def ProcessMaskFile(self, file, header):
		mf = file.readlines()

		# try to drop copyright, examples etc.
		ccb = None # current comment block
		gotwhite = True # whitespace status

		for i in range(len(mf)):
			if mf[i].startswith('#'):
				if gotwhite:
					ccb = i
					gotwhite = False
			elif not mf[i].strip():
				gotwhite = True
			else: # package atom
				if ccb is not None:
					del mf[:ccb]
				break

		self.extend(['\n', '## *%s*\n' % header, '\n'])
		self.extend(mf)

	def ProcessRepos(self):
		for o in self.portdb.getRepositories():
			path = self.portdb.getRepositoryPath(o)
			try:
				maskf = codecs.open(os.path.join(path, 'profiles', 'package.mask'), 'r', 'utf8')
			except IOError:
				pass
			else:
				self.ProcessMaskFile(maskf, o)

	def ProcessProfiles(self):
		for p in portage.settings.profiles:
			try:
				maskf = codecs.open(os.path.join(p, 'package.mask'), 'r', 'utf8')
			except IOError:
				pass
			else:
				profname = 'profile: %s' % os.path.relpath(p, os.path.join(self.portdb.porttree_root, 'profiles'))
				self.ProcessMaskFile(maskf, profname)

	def ProcessAll(self):
		self.ProcessRepos()
		self.ProcessProfiles()

	def __init__(self, dbapi):
		self.portdb = dbapi
		self.ProcessAll()

def update(unmask, mask, dbapi):
	""" Update unmasks according to current package.mask file and remove old ones. """
	if mask is None:
		mask = MaskFile(MaskMerge(dbapi))
	elif isinstance(mask, MaskMerge):
		mask = MaskFile(mask)
	if not isinstance(unmask, UnmaskFile):
		unmask = UnmaskFile(unmask)

	return (UnmaskFileClean(mask, unmask), mask)

def vimdiff(vimdiffcmd, unmaskpath, m, dbapi):
	""" vimdiff merged package.mask with package.unmask. """
	if isinstance(unmaskpath, UnmaskFile):
		unmaskpath = unmaskpath.write()
	if m is None:
		m = MaskMerge(dbapi)

	t = tempfile.NamedTemporaryFile()
	t.write(m.toString().encode('utf8'))
	t.flush()

	os.system('%s "%s" "%s"' % (vimdiffcmd, t.name, unmaskpath))
	return (unmaskpath, m)

def find_cpv_match(mask, cpv, comment = None, dbapi = None):
	""" Try to get first good match for cpv and the comment in the mask
		file. """
	def repo_iter(f):
		for r in mask:
			for b in r:
				yield (r, b)

	if dbapi is not None:
		slot = dbapi.aux_get(cpv, ['SLOT'])[0]
		if slot:
			cpv = '%s:%s' % (cpv, slot)

	match = None
	for r, b in repo_iter(mask):
		if cpv in b:
			match = (r, b)
			# getmaskingreason() can sometime provide a broken comment,
			# so don't require a match (but prefer one)
			if comment is None or b.comment == comment:
				break

	if match is None:
		raise ValueError('CPV not matched anything in the file')

	return match

def add(pkgs, unmask, mask, dbapi):
	""" Unmask specified packages. """
	if mask is None:
		mask = MaskFile(MaskMerge(dbapi))
	elif isinstance(mask, MaskMerge):
		mask = MaskFile(mask)
	if not isinstance(unmask, UnmaskFile):
		unmask = UnmaskFile(unmask)

	for pkg in pkgs:
		matches = dbapi.xmatch('match-all', pkg)
		if not matches:
			print('No packages match %s.' % pkg)
			return

		skipping = False
		while len(matches) > 0:
			bm = portage.best(matches)
			ms = portage.getmaskingstatus(bm)

			if skipping:
				if ms:
					print("(if you'd like to unmask the older version,\n pass <=%s instead)" % bm)
					break
			elif not ms:
				print('%s is visible, skipping the atom.' % bm)
				skipping = True
			elif ms != ['package.mask']:
				print('%s is masked by: %s; skipping.' % (bm, ', '.join(ms)))
			else:
				mr = portage.getmaskingreason(bm).splitlines(True)
				if not mr[0].startswith('#'):
					raise AssertionError("portage.getmaskingreason() didn't return a comment")

				try:
					(r, b) = find_cpv_match(mask, bm, mr, dbapi)
				except ValueError:
					print('Unable to find a matching mask for %s.' % bm)
				else:
					print('Unmasking %s.' % bm)

					try:
						ur = unmask[r.name]
					except KeyError:
						ur = unmask.MaskRepo(r.name)
						unmask.append(ur)

					ur.append(b)
				break

			matches.remove(bm)
		else:
			print("No '%s' suitable for unmasking found." % pkg)

	return (unmask, mask)

def delete(pkgs, unmask, mask, dbapi):
	""" Delete unmask entries for specified packages. """
	if not isinstance(unmask, UnmaskFile):
		unmask = UnmaskFile(unmask)

	for pkg in pkgs:
		matches = dbapi.xmatch('match-visible', pkg)
		if not matches:
			print('No packages match %s.' % pkg)
			return

		skipping = False
		while len(matches) > 0:
			bm = portage.best(matches)

			try:
				(r, b) = find_cpv_match(unmask, bm, dbapi = dbapi)
			except ValueError:
				print('No mask for %s found.' % bm)
			else:
				print('Removing unmask for %s.' % bm)
				r.remove(b)

				# Feel free to remove an empty repository.
				if not r:
					unmask.remove(r)
				break

			matches.remove(bm)
		else:
			print("No '%s' suitable for un-unmasking found." % pkg)

	return (unmask, mask)

def main(argv):
	defpunmask = os.path.join(portage.settings['PORTAGE_CONFIGROOT'],
			'etc', 'portage', 'package.unmask')
	if os.path.isdir(defpunmask):
		defpunmask = os.path.join(defpunmask, 'diffmask')
	parser = optparse.OptionParser(version=MY_PV, usage='%prog <actions> [options] [packages]')
	parser.add_option('-U', '--unmask-file', action='store',
			dest='unmask', default=defpunmask,
			help='package.unmask file location')

	gr = optparse.OptionGroup(parser, 'Actions')
	gr.add_option('-a', '--add', action='append_const',
			dest='mode', const='add', help=add.__doc__.strip())
	gr.add_option('-d', '--delete', action='append_const',
			dest='mode', const='delete', help=delete.__doc__.strip())
	gr.add_option('-u', '--update', action='append_const',
			dest='mode', const='update', help=update.__doc__.strip())
	gr.add_option('-v', '--vimdiff', action='append_const',
			dest='mode', const='vimdiff', help=vimdiff.__doc__.strip())
	parser.add_option_group(gr)

	gr = optparse.OptionGroup(parser, 'Options related to vimdiff')
	gr.add_option('--vimdiffcmd', action='store',
			dest='vimdiff', default='vimdiff', help='vimdiff command')
	parser.add_option_group(gr)

	(opts, args) = parser.parse_args(args=argv[1:])

	if not opts.mode:
		if os.path.basename(argv[0]).startswith('vimdiff'):
			opts.mode = ('vimdiff')
		else:
			parser.print_help()
			return 2

	opts.mode = frozenset(opts.mode)
	if 'add' in opts.mode and 'delete' in opts.mode:
		parser.error('--add and --delete arguments are exclusive.')
		return 2
	if not args and ('add' in opts.mode or 'delete' in opts.mode):
		parser.error('--and and --delete actions require at least a single package')
		return 2

	trees = portage.create_trees()
	portdb = trees[portage.settings['ROOT']]['porttree'].dbapi
	unmask = opts.unmask
	mask = None

	if 'add' in opts.mode:
		(unmask, mask) = add(args, unmask, mask, dbapi = portdb)
	elif 'delete' in opts.mode:
		(unmask, mask) = delete(args, unmask, mask, dbapi = portdb)
	if 'update' in opts.mode:
		(unmask, mask) = update(unmask, mask, dbapi = portdb)
	if 'vimdiff' in opts.mode:
		(unmask, mask) = vimdiff(opts.vimdiff, unmask, mask, dbapi = portdb)

	if isinstance(unmask, UnmaskFile):
		unmask.write()

	return 0

if __name__ == '__main__':
	sys.exit(main(sys.argv))
