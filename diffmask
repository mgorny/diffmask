#!/usr/bin/python
#	vim:fileencoding=utf-8
# Create merged 'package.mask' file and maintain 'package.unmask' using it
# (C) 2010 Michał Górny, distributed under the terms of 3-clause BSD license

MY_PN='diffmask'
MY_PV='0.3.1'

import codecs, optparse, os, os.path, sys, tempfile
import portage

def toString(obj):
	if hasattr(obj, 'toString'):
		return obj.toString()
	else:
		return obj

class DiffmaskList(list):
	""" A list class extended with a simple toString() method. """
	def toString(self):
		return ''.join([toString(x) for x in self])

class MaskFile(DiffmaskList):
	class MaskRepo(DiffmaskList):
		class MaskBlock(DiffmaskList):
			""" A single block of package.mask file. Basically a list of
				atoms, keeping the comments as well. """

			def __eq__(self, other):
				return (self.comment == other.comment and DiffmaskList.__eq__(self, other))

			def toString(self):
				return ''.join(self.before + self.comment + self + self.after)

			def __init__(self, data):
				DiffmaskList.__init__(self)
				self.before = []
				self.comment = []
				self.after = []

				for l in data:
					if len(self) == 0:
						if len(self.comment) == 0 and l.strip() == '':
							self.before.append(l)
						elif l.startswith('#') or l.strip() == '':
							self.comment.append(l)
						else:
							self.append(l)
					elif l.startswith('#') or l.strip() == '':
						self.after.append(l)
					else:
						self.append(l)

		def AppendBlock(self, data):
			self.append(self.MaskBlock(data))

		def toString(self):
			out = []
			if self.name:
				out.append('\n## *%s*\n\n' % self.name)
			out.extend([x.toString() for x in self])
			return ''.join(out)

		def __init__(self, name):
			DiffmaskList.__init__(self)
			self.name = name

	def GetRepo(self, name):
		for r in self:
			if r.name == name:
				return r
		raise KeyError('No such repo')

	def __init__(self, data):
		repo = self.MaskRepo(None)
		DiffmaskList.__init__(self, [repo])
		buf = []
		gotatoms = False

		for l in data:
			if l.startswith('#'):
				newrepo = (l.startswith('## *') and l.endswith('*\n')) # repo name

				if gotatoms or newrepo:
					repo.AppendBlock(buf)
					buf = []
					gotatoms = False
				if newrepo:
					repo = self.MaskRepo(l[4:-2])
					self.append(repo)
					continue
			elif ''.join(l).strip() != '':
				gotatoms = True
			buf.append(l)

		if ''.join(buf).strip() != '':
			repo.AppendBlock(buf)

		# cleanup leading/trailing whitespace (one belonging to repo header)
		for r in self:
			try:
				if r[0].before[0] == '\n':
					del r[0].before[0]
			except IndexError:
				pass
			try:
				if r[-1].after[-1] == '\n':
					del r[-1].after[-1]
			except IndexError:
				pass

class UnmaskFile(MaskFile):
	def __init__(self, path):
		if os.path.exists(path):
			data = codecs.open(path, 'r', 'utf8').readlines()
		else:
			data = []
		MaskFile.__init__(self, data)

class UnmaskFileClean:
	class UnmaskRepoClean:
		def toString(self):
			out = []
			if self.name:
				out.append('\n## *%s*\n\n' % self.name)
			out.extend([x.toString() for x in self.blocks])
			return ''.join(out)

		def __init__(self, maskr, unmaskr, noner):
			""" Try to match blocks in unmaskr (unmask entries associated with repo)
				and noner (unassociated unmask entries) to those in maskr (mask entries
				associated with repo). Create blocklist containing matched entries. """
			self.name = maskr.name
			self.blocks = []
			inblocks = []
			tblocks = []

			if unmaskr is not None:
				inblocks.extend(unmaskr)
			if noner is not None:
				inblocks.extend(noner)

			for b in inblocks:
				# first try to get exact match
				for cb in maskr:
					if cb == b:
						tblocks.append(cb)
						break
				else:
					# then try partial matches
					for cb in maskr:
						if cb.comment == b.comment:
							tblocks.append(cb)
							break
					for a in b:
						for cb in maskr:
							if a in cb:
								tblocks.append(cb)
								break

			# sort & unify, now we have to get exact matches
			for b in tblocks:
				for cb in maskr:
					if cb == b:
						for ub in self.blocks: # unify
							if cb == ub:
								break
						else:
							self.blocks.append(cb)
						break
				else:
					raise AssertionError('Match failed in sorting loop')

	def toString(self):
		return ''.join([x.toString() for x in self.repos])

	def __init__(self, mask, unmask):
		""" Update and cleanup 'unmask' file to match 'mask' file. """
		self.repos = []

		# find the repo containing unmatched entries
		# (in fact it should be always the first one but better safe than sorry)
		for r in unmask:
			if r.name is None:
				nonerepo = r
				break
		else:
			nonerepo = None

		for mr in mask:
			if mr.name is not None:
				try:
					r = unmask.GetRepo(mr.name)
				except KeyError: # repo only in mask file
					r = None

				outr = self.UnmaskRepoClean(mr, r, nonerepo)
				if len(outr.blocks):
					self.repos.append(outr)

		# repos which are only in unmask file are dropped implicitly

class MaskMerge(DiffmaskList):
	def ProcessMaskFile(self, file, header):
		mf = file.readlines()

		# try to drop copyright, examples etc.
		ccb = None # current comment block
		gotwhite = True # whitespace status

		for i in range(len(mf)):
			if mf[i].startswith('#'):
				if gotwhite:
					ccb = i
					gotwhite = False
			elif mf[i].strip() == '':
				gotwhite = True
			else: # package atom
				if ccb is not None:
					del mf[:ccb]
				break

		self.extend(['\n', '## *%s*\n' % header, '\n'])
		self.extend(mf)

	def ProcessRepos(self):
		for o in self.portdb.getRepositories():
			path = self.portdb.getRepositoryPath(o)
			try:
				maskf = codecs.open(os.path.join(path, 'profiles', 'package.mask'), 'r', 'utf8')
			except IOError:
				pass
			else:
				self.ProcessMaskFile(maskf, o)

	def ProcessProfiles(self):
		for p in portage.settings.profiles:
			try:
				maskf = codecs.open(os.path.join(p, 'package.mask'), 'r', 'utf8')
			except IOError:
				pass
			else:
				profname = 'profile: %s' % os.path.relpath(p, os.path.join(self.portdb.porttree_root, 'profiles'))
				self.ProcessMaskFile(maskf, profname)

	def ProcessAll(self):
		self.ProcessRepos()
		self.ProcessProfiles()

	def __init__(self, dbapi):
		self.portdb = dbapi
		self.ProcessAll()

def update(unmaskpath, dbapi, unmask = None):
	""" Update unmasks according to current package.mask file and remove old ones. """
	mask = MaskFile(MaskMerge(dbapi))
	if unmask is None:
		unmask = UnmaskFile(unmaskpath)

	cmp = UnmaskFileClean(mask, unmask)

	scmp = cmp.toString()
	if scmp.strip() == unmask.toString().strip():
		print('The unmask file is up-to-date.')
	else:
		newfn = portage.util.new_protect_filename(unmaskpath)
		# Always try hard to get a diff.
		if newfn == unmaskpath:
			open(newfn, 'w').close()
			newfn = portage.util.new_protect_filename(unmaskpath)
		newf = codecs.open(newfn, 'w', 'utf8')
		newf.write(cmp.toString())

		print('New package.unmask saved as %s.\nPlease run dispatch-conf or etc-update to merge it.' % newfn)

def vimdiff(vimdiffcmd, unmaskpath, dbapi):
	""" vimdiff merged package.mask with package.unmask. """
	m = MaskMerge(dbapi)
	t = tempfile.NamedTemporaryFile()
	t.write(m.toString().encode('utf8'))
	t.flush()
	os.system('%s "%s" "%s"' % (vimdiffcmd, t.name, unmaskpath))

def add(pkgs, unmaskpath, dbapi):
	""" Unmask specified packages. """
	unmask = UnmaskFile(unmaskpath)
	nonerepo = unmask.GetRepo(None)

	for pkg in pkgs:
		matches = dbapi.xmatch('match-all', pkg)
		if len(matches) == 0:
			print('No packages match %s.' % pkg)
			return

		while len(matches) > 0:
			bm = portage.best(matches)
			ms = portage.getmaskingstatus(bm)

			if len(ms) == 0:
				print('%s is visible, skipping.' % bm)
			elif 'package.mask' not in ms or len(ms) > 1:
				print('%s is masked by: %s; skipping.' % (bm, ', '.join(ms)))
			else:
				mr = portage.getmaskingreason(bm).splitlines(True)
				if not mr[0].startswith('#'):
					raise AssertionError("portage.getmaskingreason() didn't return a comment")

				print('Trying to unmask %s.' % bm)
				# getmaskingreason() can sometime provide a broken comment
				# so let's hope it or =pkg match will occur
				mr.extend(['=%s\n' % bm, '\n'])
				nonerepo.AppendBlock(mr)
				break

			matches.remove(bm)
		else:
			print('No packages matching %s and being only package.mask-masked were found.' % pkg)

	update(unmaskpath, dbapi, unmask)

def main(argv):
	defpunmask = os.path.join(portage.settings['PORTAGE_CONFIGROOT'],
			'etc', 'portage', 'package.unmask')
	if os.path.isdir(defpunmask):
		defpunmask = os.path.join(defpunmask, 'diffmask')
	parser = optparse.OptionParser(version=MY_PV, usage='%prog <action> [options]')
	parser.add_option('-U', '--unmask-file', action='store',
			dest='unmask', default=defpunmask,
			help='package.unmask file location')

	gr = optparse.OptionGroup(parser, 'Actions')
	gr.add_option('-a', '--add', action='store_const',
			dest='mode', const='add', help=add.__doc__.strip())
	gr.add_option('-u', '--update', action='store_const',
			dest='mode', const='update', help=update.__doc__.strip())
	gr.add_option('-v', '--vimdiff', action='store_const',
			dest='mode', const='vimdiff', help=vimdiff.__doc__.strip())
	parser.add_option_group(gr)

	gr = optparse.OptionGroup(parser, 'Options related to vimdiff')
	gr.add_option('--vimdiffcmd', action='store',
			dest='vimdiff', default='vimdiff', help='vimdiff command')
	parser.add_option_group(gr)

	(opts, args) = parser.parse_args(args=argv[1:])

	if opts.mode is None:
		if os.path.basename(argv[0]).startswith('vimdiff'):
			opts.mode = 'vimdiff'
		else:
			parser.print_help()
			return 2

	portdb = portage.db[portage.settings['ROOT']]['porttree'].dbapi
	if opts.mode == 'vimdiff':
		vimdiff(opts.vimdiff, opts.unmask, dbapi = portdb)
	elif opts.mode == 'update':
		update(opts.unmask, dbapi = portdb)
	elif opts.mode == 'add':
		if len(args) == 0:
			print('--add requires at least a single package name.')
			return 2
		add(args, opts.unmask, dbapi = portdb)

	return 0

if __name__ == '__main__':
	sys.exit(main(sys.argv))
